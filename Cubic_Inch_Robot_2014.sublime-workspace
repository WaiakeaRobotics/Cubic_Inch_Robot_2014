{
	"auto_complete":
	{
		"selected_items":
		[
		]
	},
	"buffers":
	[
		{
			"contents": "// ================================================================\n// ===         2014 Waiakea Robotics Cubic Inch Robot           ===\n// ================================================================\n/*\n\n5/23/2014\n\nThe MPU6050_DMP6 example was used as the starting point for this program \n\nFinal goal is to navigate a fixed grid maze using the gyroscope sensor and front IR sensors to detect gaps in the \"maze\"\nThe \"maze\" is not a real maze but actually a grid of blocks arranged in a 3 x 3 pattern with each block being 150mm square and a 30mm gap between them.\nThe goal is to drive over the 7 control points. Further details are here: http://imd.eng.kagawa-u.ac.jp/maze/reg_c2.html\nThe difficulty is doing this with a robot fitting in 1 cubic inch and also doing it faster than all of your opponents as the fastest robot wins. \n\nThere is also a human driver controlled category in the competition, so this program also will have a user operated mode.\nAutonomous mode will most likely be activated by pushing a certain button on the remote control. \n\nThe remote control has the same 2.4ghz transceiver connected to the SPI port so they can communicate both ways.  \nThe remote contains 8 pushbuttons, arranged in two \"D\" pads one on the left and one on the right.\nIt also contains a 128x64 pixel OLED display wired to the I2C port. \n\nProgramming both the robot and the remote is facilitated by a USB to serial converter IC located on the remote PCB. \nThere is a switch on the remote to select whether the serial port goes to the robot or the remote. \nThe robot is physically connected to the remote control for programming and charging via a magnetic pogo pin connector for ease of use. \n\nPossibly the remote will also have a serial passthrough mode to allow the computers serial terminal to communicate with the robot remotely.\nThe other option for reading real time data from the robot is to use the OLED display on the remote as a display terminal. \n\nBoth the robot and remote have 2:1 voltage dividers to allow battery voltage monitoring in real time. \n\nThey are both powered by lithium polymer recharable batteries. \nThe remote contains chargers for both batteries that are powered through the same USB port used for programming. \n\nThe locally included PID library has been modified to allow its use with continuous rotation inputs that roll over. \nIE with a gyro input from 0 - 360 that will rollover from 360 back to 0 if it is turned further to the right.\nThe library had to be modified so it treats 0 and 360 as the same value because it may be faster to go upwards from say 300 degrees to get to 10 degrees \nversus going down all the way to 10 if it was not aware of the loopover effect of absolute angular data. \n\n\n*/\n// ================================================================\n// ===                       Gyro Includes                      ===\n// ================================================================\n\n// I2Cdev and MPU6050 must be installed as libraries\n#include \"I2Cdev.h\"\n#include \"MPU6050_6Axis_MotionApps20.h\"\n\n// Arduino Wire library is required if I2Cdev I2CDEV_ARDUINO_WIRE implementation\n// is used in I2Cdev.h\n#if I2CDEV_IMPLEMENTATION == I2CDEV_ARDUINO_WIRE\n#include \"Wire.h\"\n#endif\n\n// specific I2C addresses may be passed as a parameter here\n// MPU6050 PIN AD0 low = 0x68 (default)\nMPU6050 mpu;\n\n/* =========================================================================\n   NOTE: In addition to connection 3.3v, GND, SDA, and SCL, this sketch\n   depends on the MPU-6050's INT pin being connected to the Arduino's\n   external interrupt #0 pin. On the Arduino Uno and Mega 2560, this is\n   digital I/O pin 2.\n * =====================================\n ==================================== */\n\n// MPU6050 Gyro control/status vars\nbool dmpReady = false;  // set true if DMP init was successful\nuint8_t mpuIntStatus;   // holds actual interrupt status byte from MPU\nuint8_t devStatus;      // return status after each device operation (0 = success, !0 = error)\nuint16_t packetSize;    // expected DMP packet size (default is 42 bytes)\nuint16_t fifoCount;     // count of all bytes currently in FIFO\nuint8_t fifoBuffer[64]; // FIFO storage buffer\n\n// orientation/motion vars\nQuaternion q;           // [w, x, y, z]         quaternion container\nVectorInt16 aa;         // [x, y, z]            accel sensor measurements\nVectorInt16 aaReal;     // [x, y, z]            gravity-free accel sensor measurements\nVectorInt16 aaWorld;    // [x, y, z]            world-frame accel sensor measurements\nVectorFloat gravity;    // [x, y, z]            gravity vector\nfloat euler[3];         // [psi, theta, phi]    Euler angle container\nfloat ypr[3];           // [yaw, pitch, roll]   yaw/pitch/roll container and gravity vector\n\n// Interrupt routine for Gyro\nvolatile bool mpuInterrupt = false;     // indicates whether MPU interrupt pin has gone high\nvoid dmpDataReady(){\n  mpuInterrupt = true;\n}\n\n// ================================================================\n// ===               2.4Ghz Transceiver Includes                ===\n// ================================================================\n\n#include <SPI.h>  // Library for SPI communications used by the nRF24L01 radio\n\n#include <RH_NRF24.h>\nRH_NRF24 nrf24(8, 14); //CE, CSN\n\n// ================================================================\n// ===                    PID Library Includes                  ===\n// ================================================================\n#include \"PID_CL_2014.h\"\n\n//Define Variables we'll be connecting to\ndouble setpoint, input, output;\n\n//Specify the links and initial tuning parameters\nPID myPID(&input, &output, &setpoint,.5,0,0, REVERSE);\n// Last input \"DIRECT\" or \"REVERSE\" will change which way the correction value goes\n//switch them if the correction  makes things worse\n\n// ================================================================\n// ===                    Robot Pin Defines                     ===\n// ================================================================\n\n// Lets define some nice handy constants eh?\n\n#define LED_R 13 // Red LED - Shared with SCK used for NRF24L01 Transceiver\n#define LED_G 0  // Green LED - Shared with serial port radio pin\n#define LED_B 4  // Blue LED\n\n#define LED_ON 0 // LEDs are active LOW\n#define LED_OFF 1 // LEDs are active LOW\n\n//Pull these pins high to enable a specific LED\n//Cathode is connected to 38khz pin\n\n#define IR_LED_R 1 // IR LED Left used for reflective wall sensing\n#define IR_LED_L 7 // IR LED Left used for reflective wall sensing\n#define IR_38Khz 3    // IR LED 38khz Cathode connection\n\n#define IR_SENSOR_R 15 // Right input from 38khz bandpass filter connected to IR PIN diode\n#define IR_SENSOR_L 16 // \n\n#define WALL_DETECTED 0 // Wall detected\n#define WALL_NOT_DETECTED 1 // Wall not detected\n\n\n#define MOTOR_R_DIR 5 // Right motor direction pin\n#define MOTOR_R_SPD 9 // Right motor speed pin - apply PWM signal (analog out) to this pin\n#define MOTOR_L_DIR 6\n#define MOTOR_L_SPD 10\n\n#define BATT_VOLTAGE 17 //Battery voltage monitor pin - connected to 50% divider to allow the measurment of voltages higher than the vcc of 3.3v\n\n#define FWD 0 // 0 = forward in our robot wiring\n#define BWD 1 // 1 = backward in our robot wiring\n\n// The below defines are for the bit location of the corresponding buttons in our 8 bit encoded buttons variable received from the transmitter\n#define A 0  // Right D pad up button\n#define B 1  // Right D pad right button\n#define C 2  // Right D pad down button\n#define D 3  // Right D pad left button\n\n#define UP 4    // Left D pad up button\n#define RIGHT 5 // Left D pad right button\n#define DOWN 6  // Left D pad down button\n#define LEFT 7  // Left D pad left button\n\n// ================================================================\n// ===                  Variable Definitions                    ===\n// ================================================================\n\nuint8_t sendBuffer[7];  // 28 element array of unsigned 8-bit type - 28 is the max message length for the nrf24L01 radio\nuint8_t receiveBuffer[2];\nuint8_t lengthReceive = sizeof(receiveBuffer);\n\n//String message; // Used by radio code - may not be final\nunsigned char buttons; // value of the buttons received from the remote\nunsigned char buffer; // receive variable\nunsigned char bufferLast; // last received variable\n\nint receiveCheck;\n\nint iteration=0;\n\nbool blinkState = false;\nbool blinkState1 = false;\nbool blinkState2 = false;\n\nbool startAButton;\nbool startBButton;\nbool startCButton;\nbool startDButton;\n\nint yaw = 0;\nint yawLast = 0;\nint yawContinuous = 0;\nint startYawContinuous = 0;\nint yawRotationCount = 0;\nint battVoltage;\n//int yawStart = 0;\n//int yawDiff = 0;\n\nint outputInt;\n\nint forwardRamp;\nint forwardRampD;\nint forwardRampAuto;\nint loopTimer;\n\nint slowTimer;\n\nint stateMachine;\n\nunsigned long lastMillis, timeAway;\nunsigned long lastMillisAuto;\nunsigned long lastMillisGyro, timeAwayGyro;\n\nunsigned char sendCounter;\n\n// ================================================================\n// ===                  SOFTWARE MOD FUNCTION                   ===\n// ================================================================\n\nint smod(int z1, int z2) { // Software MOD function\n  int ze;\n  ze=z1 % z2;\n  if (ze>=0)  {\n    return(ze);\n  }\n  else{\n    return(z2+ze);\n  }\n}\n\n// ================================================================\n// ===                      INITIAL SETUP                       ===\n// ================================================================\n\nvoid setup() {\n  \n//  Serial.begin(115200); // Serial turned off because Green LED uses same pin as RX, IR LED Right uses same pin as TX\n\n// ================================================================\n// ===                        GYRO SETUP                        ===\n// ================================================================\n\n  #if I2CDEV_IMPLEMENTATION == I2CDEV_ARDUINO_WIRE // join I2C bus (I2Cdev library doesn't do this automatically)\n  Wire.begin();\n  TWBR = 2; //2 = 800khz I2C - fastest possible data rate\n  #elif I2CDEV_IMPLEMENTATION == I2CDEV_BUILTIN_FASTWIRE\n  Fastwire::setup(400, true);\n  #endif\n  \n  mpu.initialize();\n  devStatus = mpu.dmpInitialize();\n  \n  mpu.setXGyroOffset(220); // supply your own gyro offsets here, scaled for min sensitivity\n  mpu.setYGyroOffset(76);\n  mpu.setZGyroOffset(-85);\n  mpu.setZAccelOffset(1788); // 1688 factory default for my test chip\n  \n  if (devStatus == 0) { // make sure it worked (returns 0 if so)\n    mpu.setDMPEnabled(true);  // turn on the DMP, now that it's ready\n    \n    attachInterrupt(0, dmpDataReady, RISING); // enable Arduino interrupt detection\n    mpuIntStatus = mpu.getIntStatus();\n    \n    dmpReady = true; // set our DMP Ready flag so the main loop() function knows it's okay to use it\n    \n    packetSize = mpu.dmpGetFIFOPacketSize(); // get expected DMP packet size for later comparison\n  }\n\n// ================================================================\n// ===                     Robot Pin Setup                      ===\n// ================================================================\n\n  pinMode(LED_G, OUTPUT); // configure LED for output\n  pinMode(LED_B, OUTPUT);\n  \n  digitalWrite(LED_G, 1);// 1 = off\n  digitalWrite(LED_B, 1);\n  \n  pinMode(IR_LED_R, OUTPUT);\n  pinMode(IR_LED_L, OUTPUT);\n  \n  pinMode(IR_38Khz, OUTPUT);\n  \n  digitalWrite(IR_LED_R, 1); // 0 = off\n  digitalWrite(IR_LED_L, 1); // 0 = off\n  digitalWrite(IR_38Khz, 0);\n  \n  pinMode(MOTOR_R_DIR, OUTPUT);\n  pinMode(MOTOR_R_SPD, OUTPUT);\n  pinMode(MOTOR_L_DIR, OUTPUT);\n  pinMode(MOTOR_L_SPD, OUTPUT);\n  \n  digitalWrite(MOTOR_R_DIR, FWD);\n  analogWrite(MOTOR_R_SPD, 0);\n  digitalWrite(MOTOR_L_DIR, FWD);\n  analogWrite(MOTOR_L_SPD, 0);\n  \n  pinMode(BATT_VOLTAGE, INPUT);\n  \n  pinMode(IR_SENSOR_R, INPUT);\n  pinMode(IR_SENSOR_L, INPUT);\n  \n// ================================================================\n// ===               2.4Ghz Transceiver Setup                   ===\n// ================================================================  \n\n  //nrf24.init();\n  \n  if (!nrf24.init())\n  Serial.println(\"Radio init failed\");\n  // Defaults after init are 2.402 GHz (channel 2), 2Mbps, 0dBm\n  nrf24.setChannel(2); // Set the desired Transceiver channel valid values are 0-127, in the US only channels 0-83 are within legal bands\n  nrf24.setRF(RH_NRF24::DataRate2Mbps, RH_NRF24::TransmitPower0dBm);   \n  \n// ================================================================\n// ===                 PID Feedback Loop Setup                   ===\n// ================================================================ \n\nsetpoint = 1800;	\nmyPID.SetOutputLimits(-10,10);\nmyPID.SetSampleTime(0);\n  myPID.SetMode(AUTOMATIC); //Initialize PID parameters\n  \n// ================================================================\n// ===                       38Khz SETUP                        ===\n// ================================================================ \n\npinMode(3, OUTPUT);\n  TCCR2A = _BV(COM2B1) | _BV(WGM21) | _BV(WGM20); // Just enable output on Pin 3 and disable it on Pin 11\n  TCCR2B = _BV(WGM22) | _BV(CS22);\n  OCR2A = 51; // defines the frequency 51 = 38.4 KHz, 54 = 36.2 KHz, 58 = 34 KHz, 62 = 32 KHz\n  OCR2B = 26;  // deines the duty cycle - Half the OCR2A value for 50%\n  TCCR2B = TCCR2B & 0b00111000 | 0x2; // select a prescale value of 8:1 of the system clock\n  \n// ================================================================\n// ===           FINAL ACTIONS BEFORE EXITING SETUP             ===\n// ================================================================  \n  analogWrite(MOTOR_R_SPD, 0); // Make sure both motors are off\n  analogWrite(MOTOR_L_SPD, 0);\n  \n}// end setup loop\n\n\n// ================================================================\n// ===                    MAIN PROGRAM LOOP                     ===\n// ================================================================\n\nvoid loop() {\n  \n \n// ================================================================\n// ===              READ GYRO AND CALCULATE ANGLE               ===\n// ================================================================\n  // reset interrupt flag and get INT_STATUS byte\n  mpuInterrupt = false;\n  mpuIntStatus = mpu.getIntStatus();\n  \n  // get current FIFO count\n  fifoCount = mpu.getFIFOCount();\n  \n  // check for overflow (this should never happen unless our code is too inefficient)\n  if ((mpuIntStatus & 0x10) || fifoCount == 1024) {\n    // reset so we can continue cleanly\n    mpu.resetFIFO();  \n    //Serial.println(F(\"FIFO overflow!\"));\n    \n    // otherwise, check for DMP data ready interrupt (this should happen frequently)\n  } \n  else if (mpuIntStatus & 0x02) {\n    // wait for correct available data length, should be a VERY short wait\n    while (fifoCount < packetSize) fifoCount = mpu.getFIFOCount();\n    \n    timeAwayGyro = millis() - lastMillisGyro;\n    lastMillisGyro = millis();\n    // read a packet from FIFO\n    mpu.getFIFOBytes(fifoBuffer, packetSize);\n    \n    // track FIFO count here in case there is > 1 packet available\n    // (this lets us immediately read more without waiting for an interrupt)\n    fifoCount -= packetSize;\n    \n    // Get the Euler angles in degrees\n    mpu.dmpGetQuaternion(&q, fifoBuffer);\n    mpu.dmpGetGravity(&gravity, &q);\n    mpu.dmpGetYawPitchRoll(ypr, &q, &gravity);\n    //Serial.print(ypr[0] * 180/M_PI);\n    \n    //yaw = ypr[0] * 57.32;    // Scale -180 to +180 degrees\n    //yaw = yaw + 180;         // Scale to 0 - 360 degrees\n    \n    yaw = ypr[0] * 573.2; // Scale to -1800 - +1800 degrees\n    yaw = yaw + 1800; // Scale to 0 - 3600 degrees\n    \n    if ((yaw > 2700) && (yawLast < 900)) // did tollover occur from low to high = Left \n    {\n      yawRotationCount --;\n    }\n    else if((yaw < 900) && (yawLast > 1800)) // did rollover occur from high to low = right\n    {\n      yawRotationCount ++;\n    }\n    \n    yawContinuous = yaw + (yawRotationCount * 3600);\n    yawLast = yaw;\n    \n    //yawDiff = yawStart - yaw;\n    //yawDiff = yawDiff % 3600;\n    //yawDiff = smod(yawDiff, 3600); \n    //yawDiff = yawStart         // Use software mod function to constrain variables\n    \n    //setpoint = yaw - 90;\n    //yawInt = yaw;\n    //setpoint = (yaw - 900) % 3600;   // need to see if this works for -180 +180 constraint\n    \n     // Serial.print(\"ypr\\t\");\n     // Serial.print(yaw);           // This is just for debugging will not go into final code\n    //Serial.print(\"\\t\");\n    //Serial.print(setpoint);\n    \n    //setpoint = 1800; // set in setup\n    input = yaw; // done in setup of PID\n    \n    /*\n    P_Param is %OutputSpan/%InputSpan (where % is calculated using the Input and Output Limits)\n    I_Param and D_Param are both seconds\n   \n    Parameters and what they do (sort of)\n    P_Param: the bigger the number the harder the controller pushes.\n    I_Param: the SMALLER the number (except for 0, which turns it off,)  the more quickly the controller reacts to load changes, but the greater the risk of oscillations.\n    D_Param: the bigger the number  the more the controller dampens oscillations (to the point where performance can be hindered)\n    */\n    \n    myPID.Compute(); // Compute the new PID values based on the setpoint and input values\n    \n    //analogWrite(MOTOR_R_SPD,output + 100); // Modify the motor speed based on the PID output\n    \n    outputInt = output;\n    \n    \n    \n  } // End gyro update loop\n  \n  \n// ================================================================\n// ===                  READ DATA FROM REMOTE                   ===\n// ================================================================\n\n  if (nrf24.available()){ // Is there received data from the remote control?\n   \n    if (nrf24.recv(receiveBuffer, &lengthReceive)){ // receive the available data into the \"receivebuffer\" variable\n    \n    sendCounter++;\n    if (sendCounter > 20){ // Only send data back to the remote periodically so as to improve the receive speed. \n      sendCounter = 0;\n      nrf24.send(sendBuffer, sizeof(sendBuffer)); // send the data inside the \"sendBuffer\" variable\n    }\n    \n    \n    timeAway = millis() - lastMillis;\n    lastMillis = millis();\n\n    buttons = receiveBuffer[0];\n    \n    sendBuffer[0] = map(yaw, 0, 3600, 0, 255);\n    battVoltage = analogRead(BATT_VOLTAGE);\n    sendBuffer[1] = map(battVoltage,0,1023,0,255);\n    sendBuffer[2] = timeAway;\n    sendBuffer[3] = timeAwayGyro;\n    sendBuffer[4] = outputInt; // Send some new data to the remote here for debugging\n    sendBuffer[5] = 23; // Send some new data to the remote here for debugging\n    sendBuffer[6] = stateMachine; // Send some new data to the remote here for debugging\n\n    \n    if (bitRead(buttons, UP) == HIGH){ // Forward\n      \n      digitalWrite(MOTOR_R_DIR, FWD);\n      digitalWrite(MOTOR_L_DIR, FWD);\n      analogWrite(MOTOR_R_SPD, forwardRamp);\n      analogWrite(MOTOR_L_SPD, forwardRamp);\n      \n      if (forwardRamp > 240) // keep ramp value from overflowing back to 0\n      {\n        forwardRamp = 255;\n      } \n      else\n      { \n        forwardRamp = forwardRamp + 10; // increment ramp value by 1\n      }\n    }\n    else{\n      forwardRamp = 30;\n      loopTimer = 0;\n    }  \n    \n    //if (bitRead(buttons, A) == HIGH){ // use gyro to drive at 1800 deg\n    //}\n    \n    if (bitRead(buttons, B) == HIGH){ // Use gyro to turn 1800 deg to the right\n      \n      if(startBButton == true)\n      {\n        startBButton = false;\n        startYawContinuous = yawContinuous;\n        \n        digitalWrite(MOTOR_R_DIR, FWD);\n        digitalWrite(MOTOR_L_DIR, FWD);\n      }\n      \n      if (yawContinuous < (startYawContinuous + 800))\n      {\n        analogWrite(MOTOR_R_SPD, 20);\n        analogWrite(MOTOR_L_SPD, 150);\n      }\n      else\n      {\n        analogWrite(MOTOR_R_SPD, 0);\n        analogWrite(MOTOR_L_SPD, 0);\n      }\n    }\n    else\n    {\n      startBButton = true;\n    }\n    \n    if (bitRead(buttons, C) == HIGH){ // USE GYRO TO GO STRAIGHT\n      if(startCButton == true)\n      {\n        startCButton = false;\n        setpoint = yaw;\n        myPID.SetTunings(.1,.001,.001); // P, I, D tuning parameters set 1.2,0, .01\n        myPID.SetOutputLimits(-20,20);\n        myPID.SetSampleTime(0);\n      }\n      \n      digitalWrite(MOTOR_R_DIR, FWD);\n      digitalWrite(MOTOR_L_DIR, FWD);\n      \n      analogWrite(MOTOR_R_SPD, 150 + outputInt);\n      analogWrite(MOTOR_L_SPD, 150);\n    }\n    else\n    {\n      startCButton = true;\n    }\n    \n    if (bitRead(buttons, D) == HIGH) // USE GYRO TO GO STRAIGHT\n    {\n      if(startDButton == true) // First time running through this function?\n      {\n        startDButton = false;\n        forwardRampD = 30;\n        setpoint = yaw;\n        myPID.SetTunings(.1,.001,.001); // P, I, D tuning parameters set 1.2,0, .01\n        myPID.SetOutputLimits(-5,5);\n        myPID.SetSampleTime(0);\n      }\n      for (int i = 0; i < 1000; i++)\n      { \n        mpuInterrupt = false;\n        mpuIntStatus = mpu.getIntStatus();\n        \n        // get current FIFO count\n        fifoCount = mpu.getFIFOCount();\n        \n        //if ((mpuIntStatus & 0x10) || fifoCount == 1024) { // check for overflow (this should never happen unless our code is too inefficient)  \n        //  mpu.resetFIFO();  // reset so we can continue cleanly\n        //} \n        if (mpuIntStatus & 0x02) \n        {\n          while (fifoCount < packetSize) fifoCount = mpu.getFIFOCount();// wait for correct available data length, should be a VERY short wait\n          timeAwayGyro = millis() - lastMillisGyro;\n          lastMillisGyro = millis();\n          mpu.getFIFOBytes(fifoBuffer, packetSize);\n          fifoCount -= packetSize;\n          mpu.dmpGetQuaternion(&q, fifoBuffer);\n          mpu.dmpGetGravity(&gravity, &q);\n          mpu.dmpGetYawPitchRoll(ypr, &q, &gravity);\n          yaw = ypr[0] * 573.2; // Scale to -1800 - +1800 degrees\n          yaw = yaw + 1800; // Scale to 0 - 3600 degrees\n          input = yaw; // done in setup of PID\n          \n          if (forwardRampD > 245) // // once full speed reached\n          {\n            myPID.Compute(); // Compute the new PID values based on the setpoint and input values\n            outputInt = output;\n            analogWrite(MOTOR_R_SPD, 245 + outputInt); //offset output by gyro PID correction value\n            analogWrite(MOTOR_L_SPD, 245 - outputInt);\n          } \n          else\n          { \n            analogWrite(MOTOR_R_SPD, forwardRampD); // drive straight by ramp value\n            analogWrite(MOTOR_L_SPD, forwardRampD);\n            forwardRampD = forwardRampD + 5; // increment ramp value by 1\n          }\n        } // end gyro read\n      }// end for loop\n    }// end button D if statement\n    else\n    {\n      startDButton = true;\n    }\n    \n    if (bitRead(buttons, DOWN) == HIGH){ // Backwards\n      digitalWrite(MOTOR_R_DIR, BWD);\n      digitalWrite(MOTOR_L_DIR, BWD);\n      analogWrite(MOTOR_R_SPD, 100);\n      analogWrite(MOTOR_L_SPD, 100);\n    }\n    if (bitRead(buttons, LEFT) == HIGH){ // Left\n      digitalWrite(MOTOR_R_DIR, FWD);\n      digitalWrite(MOTOR_L_DIR, BWD);\n      analogWrite(MOTOR_R_SPD, 50);\n      analogWrite(MOTOR_L_SPD, 50);\n    }\n    else if (bitRead(buttons, RIGHT) == HIGH){ // Right\n      digitalWrite(MOTOR_R_DIR, BWD);\n      digitalWrite(MOTOR_L_DIR, FWD);\n      analogWrite(MOTOR_R_SPD, 50);\n      analogWrite(MOTOR_L_SPD, 50);\n    } \n    \n    if (buttons == 0) // No buttons pushed\n    {\n      analogWrite(MOTOR_R_SPD, 0);\n      analogWrite(MOTOR_L_SPD, 0);\n    }\n  }\n  \n    if (bitRead(buttons, A) == HIGH) // RUN AUTO\n    {\n      AUTO();\n    }\n    else\n    {\n      stateMachine = 0;\n    }\n    \n  } // end receive avaiable loop\n  \n  \n  digitalWrite(LED_B, digitalRead(IR_SENSOR_L)); // Set the Blue LED to turn ON when the Left IR sensor sees a wall\n  \n  if (digitalRead(IR_SENSOR_R) == WALL_DETECTED) // this if statement does the same thing as the above lines but is written with an IF statement\n  {\n    digitalWrite(LED_G, LED_ON); // Turn ON the Green LED\n  }\n  else\n  {\n    digitalWrite(LED_G, LED_OFF); // Turn OFF the Green LED\n  }\n  \n  \n\n  \n} // end main loop\n\n\nvoid AUTO()\n{\n  if (stateMachine == 0) // setup millis value\n  {  \n    lastMillisAuto = millis();\n    forwardRampAuto = 30;\n    stateMachine = 1;\n    digitalWrite(MOTOR_R_DIR, FWD);\n    digitalWrite(MOTOR_L_DIR, FWD);\n  }\n  if (stateMachine == 1) // Drive straight to end of first block\n  {\n    \n    if (forwardRampAuto > 245) // // once full speed reached\n    {\n      analogWrite(MOTOR_R_SPD, 225); // turn slightly to the right\n      analogWrite(MOTOR_L_SPD, 245);\n    } \n    else\n    { \n      analogWrite(MOTOR_R_SPD, forwardRampAuto); \n      analogWrite(MOTOR_L_SPD, forwardRampAuto);\n      forwardRampAuto = forwardRampAuto + 5; // increment ramp value\n    }\n    if ((lastMillisAuto + 50) < millis()); // wait 50ms to clear gap before checking right sensor\n    {\n      if (CheckRightSensor() == false)\n      {\n        stateMachine = 2;\n        TurnRightNinetyDegrees(1);\n      }\n    }\n  }\n  if (stateMachine == 2) // Turn right\n  {\n    TurnRightNinetyDegrees(0); // run Turn right and check if done \n  }\n  if (stateMachine == 3) // Turn right\n  {\n    analogWrite(MOTOR_R_SPD, 0); \n    analogWrite(MOTOR_L_SPD, 0);\n  }\n} // end auto function\n\nbool CheckRightSensor()\n{\n  return (!digitalRead(IR_SENSOR_R));\n}\n\nvoid TurnRightNinetyDegrees(char start)\n{\n  if(start == 1)\n  {\n    startYawContinuous = yawContinuous;\n    digitalWrite(MOTOR_R_DIR, FWD);\n    digitalWrite(MOTOR_L_DIR, FWD);\n    analogWrite(MOTOR_R_SPD, 25);\n    analogWrite(MOTOR_L_SPD, 150);\n  }\n\n  if (yawContinuous > (startYawContinuous + 700))\n  {\n    stateMachine ++;\n  }\n}\n\n",
			"file": "Cubic_Inch_Robot_2014.ino",
			"file_size": 26362,
			"file_write_time": 130592728290279194,
			"settings":
			{
				"buffer_size": 25589,
				"line_ending": "Windows"
			}
		},
		{
			"contents": "\n// ================================================================\n// ===                      Library Includes                    ===\n// ================================================================\n\n#include <SPI.h>             // Library for SPI communications used by the nRF24L01 radio\n#include <RH_NRF24.h>        // Max we can send is 28 bytes of data \nRH_NRF24 nrf24(14, 15);      //CE, CSN\n\n#include \"LOCAL_EEPROMex.h\"  // Library allowing for storage of more complicated(larger) variables in EEPROM non volatile (Flash) Memory\n\n#include <Wire.h>          // Library for I2C communications used by OLED\n#include <SeeedOLED.h>     // OLED Display library - this library was modified from the original to turn on the internal charge pump\n#include <avr/pgmspace.h>\n#include \"bitmap.h\"        // Contains the bitmap splash screen image for the remote - a little \"bling\" you may customize\nSeeedOLED Oled;            // Reference the SeeedOLED library to Oled\n\n// ================================================================\n// ===                      Robot Pin Defines                   ===\n// ================================================================\n\n#define A 2  // Right D pad up button\n#define B 8  // Right D pad right button\n#define C 9  // Right D pad down button\n#define D 10 // Right D pad left button\n\n#define UP 4    // Left D pad up button\n#define RIGHT 7 // Left D pad right button\n#define DOWN 5  // Left D pad down button\n#define LEFT 6  // Left D pad left button\n\n#define AUTO 16 // Pin A2 is connected to auto mode push button\n\n//#define LED 13 // Yellow indicator LED - Pin also used by OLED SCK pin so not usable during normal operation\n\n#define BATT_VOLTAGE 17 // Battery voltage monitor pin - connected to 50% divider to allow the measurment of voltages higher than the vcc of 3.3v\n\n#define IR_38Khz 3    // IR LED 38khz Anode connection - only used by 1 Cubic Inch robot\n// IR LED cathode connected to arduino TX pin to enable transmitting serial data using IR and normal serial UART\n\n\n// ================================================================\n// ===                  Variable Definitions                    ===\n// ================================================================\n\nuint8_t sendBuffer[2]; //array of unsigned 8-bit type - 28 is the max message length for the nrf24L01 radio\n\nuint8_t receiveBuffer[7];\nuint8_t len = sizeof(receiveBuffer);\n\nunsigned char buttons = 0; // holds current value of all 8 buttons using bit values\nchar displayCounter = 0;\nunsigned int counter;\nint yaw;\n // the receive variable type must be the same as the type being received\n\nint slowTimer; //timer for screen update\n\nunsigned long lastMillis, loopTime;\n\nint remoteBattVoltage;\n\nbool updateDisplay;\n\n// ================================================================\n// ===                      INITIAL SETUP                       ===\n// ================================================================\n\nvoid setup(){\n  \n  Serial.begin(115200); // start the serial port at 115,200 baud\n  \n// ================================================================\n// ===                     Robot Pin Setup                      ===\n// ================================================================\n\n  pinMode(A, INPUT); // Set pushbutton pins to inputs\n  pinMode(B, INPUT);\n  pinMode(C, INPUT);\n  pinMode(D, INPUT);\n  \n  pinMode(UP, INPUT);\n  pinMode(RIGHT, INPUT);\n  pinMode(DOWN, INPUT);\n  pinMode(LEFT, INPUT);\n  \n  pinMode(AUTO, INPUT);\n  \n  pinMode(BATT_VOLTAGE,INPUT);\n  \n  digitalWrite(A, HIGH); // Enable pullups on push buttons\n  digitalWrite(B, HIGH); // Enable pullups on push buttons\n  digitalWrite(C, HIGH); // Enable pullups on push buttons\n  digitalWrite(D, HIGH); // Enable pullups on push buttons\n  \n  digitalWrite(UP, HIGH); // Enable pullups on push buttons\n  digitalWrite(RIGHT, HIGH); // Enable pullups on push buttons\n  digitalWrite(DOWN, HIGH); // Enable pullups on push buttons\n  digitalWrite(LEFT, HIGH); // Enable pullups on push buttons\n\n  \n// ================================================================\n// ===                  OLED Display Setup                      ===\n// ================================================================ \n\n  Wire.begin();	//initialize I2C library\n  Oled.init();  //initialize  OLED display\n  DDRB|=0x21;         \n  PORTB |= 0x21;\n  Oled.clearDisplay();             // clear the screen and set start position to top left corner\n  Oled.drawBitmap(bitmap,1024);   // 1024 = 128 Pixels * 64 Pixels / 8\n  delay(1000); // delay 2 seconds so the splash screen is visible\n  \n  Oled.clearDisplay();          //clear the screen and set start position to top left corner\n  Oled.setNormalDisplay();      //Set display to normal mode (i.e non-inverse mode)\n  Oled.setPageMode();           //Set addressing mode to Page Mode\n  Oled.setTextXY(0,0);          //Set the cursor to Xth Page, Yth Column  \n  Oled.putString(\"Remote : \"); //Print the String \n\n  Oled.setTextXY(1,0);          //Set the cursor to Xth Page, Yth Column  \n  Oled.putString(\"Robot  : \"); //Print the String \n\n  Oled.setTextXY(2,0);          //Set the cursor to Xth Page, Yth Column  \n  Oled.putString(\"Yaw Deg: \"); //Print the String \n  \n  Oled.setTextXY(3,0);          //Set the cursor to Xth Page, Yth Column  \n  Oled.putString(\"TXRX ms: \"); //Print the String \n  \n  Oled.setTextXY(4,0);          //Set the cursor to Xth Page, Yth Column  \n  Oled.putString(\"Gyro ms: \"); //Print the String \n  \n  Oled.setTextXY(5,0);          //Set the cursor to Xth Page, Yth Column  \n  Oled.putString(\"Value 4: \"); //Print the String \n  \n  Oled.setTextXY(6,0);          //Set the cursor to Xth Page, Yth Column  \n  Oled.putString(\"Value 5: \"); //Print the String \n  \n  Oled.setTextXY(7,0);          //Set the cursor to Xth Page, Yth Column  \n  Oled.putString(\"Value 6: \"); //Print the String \n  \n  \n// ===================++===========================================\n// ===             nrF34L01 Transceiver Setup                   ===\n// ================================================================\n\nif (!nrf24.init())\nSerial.println(\"Radio init failed\");\n  // Defaults after init are 2.402 GHz (channel 2), 2Mbps, 0dBm\n  nrf24.setChannel(2); // Set the desired Transceiver channel valid values are 0-127, in the US only channels 0-83 are within legal bandslok\n  nrf24.setRF(RH_NRF24::DataRate2Mbps, RH_NRF24::TransmitPower0dBm);    \n  \n  Serial.println(\"Hi I'm your Remote\");\n  \n} // End setup function\n\n// ================================================================\n// ===                    MAIN PROGRAM LOOP                     ===\n// ================================================================\n\nvoid loop(){\n  \n  \n// ================================================================\n// ===                       Read Buttons                       ===\n// ================================================================\n\n// We use the \"bitWrite\" function to change each bit individually in the \"buttons\" variable depending on the state of each button.  \n// This allows us to store all 8 button values in one 8 bit variable which can then be easily sent to the robot for decoding. \n  bitWrite(buttons, 0, !(digitalRead(A))); //So here the bit zero bit (right most bit) in \"buttons\" will be set to the current state of the button named \"A\"\n  bitWrite(buttons, 1, !(digitalRead(B)));\n  bitWrite(buttons, 2, !(digitalRead(C)));\n  bitWrite(buttons, 3, !(digitalRead(D)));\n  bitWrite(buttons, 4, !(digitalRead(UP)));\n  bitWrite(buttons, 5, !(digitalRead(RIGHT))); \n  bitWrite(buttons, 6, !(digitalRead(DOWN)));\n  bitWrite(buttons, 7, !(digitalRead(LEFT)));\n  \n  updateDisplay = digitalRead(AUTO);\n  \n// ================================================================\n// ===                    Send Data to Robot                    ===\n// ================================================================\n\n\nloopTime = millis() - lastMillis;\nlastMillis = millis();\n\n  //if (loopTime < 6){\n    //delay(10);\n  //}\n  \n  sendBuffer[0] = buttons; \n  nrf24.send(sendBuffer, sizeof(sendBuffer));\n\n  nrf24.waitPacketSent();   // Wait for the radio to finish transmitting\n\n//delay(5);\n  //nrf24.setModeRx();\n// ================================================================\n// ===                  Read Data From Robot                    ===\n// ================================================================  \n  if (nrf24.waitAvailableTimeout(1)) // The wait time needs to be as low as possible so as to not impair the responsivness of the manual controls\n  { \n    //delay(5);\n    //if (nrf24.available()){\n      nrf24.recv(receiveBuffer, &len);\n      \n    //  Serial.print(\"Robot RX Time: \");\n    \n    Serial.println(receiveBuffer[2],DEC);\n      //Serial.print(\"                   Robot GYRO Time: \");\n      //Serial.println(receiveBuffer[3],DEC);\n      //Serial.print(\"                                         Remote Loop Time: \");\n      //Serial.println(loopTime,DEC);\n      \n      if (!updateDisplay){\n        Oled.setTextXY(0,9);   //Set the cursor to Xth Page, Yth Column\n        Oled.putFloat(analogRead(BATT_VOLTAGE) * 0.0064453); //Print remote battery voltage\n		Oled.putString(\"V\"); //Blank space to erase previous characters\n    \n        Oled.setTextXY(1,9);   //Set the cursor to Xth Page, Yth Column\n        Oled.putFloat(receiveBuffer[1] * 0.02578125);   //Print the Robot Voltage\n        Oled.putString(\"V\");  //Blank space to erase previous characters\n        \n        Oled.setTextXY(2,9);   //Set the cursor to Xth Page, Yth Column\n        Oled.putNumber(receiveBuffer[0] * 1.411); //Print the Yaw - scale 0-360\n        Oled.putString(\"   \"); //Blank space to erase previous characters\n        \n        Oled.setTextXY(3,9);          //Set the cursor to Xth Page, Yth Column\n        Oled.putNumber(receiveBuffer[2]); //Print the RX Time\n        Oled.putString(\"   \"); //Blank space to erase previous characters \n        \n        Oled.setTextXY(4,9);          //Set the cursor to Xth Page, Yth Column \n        Oled.putNumber(receiveBuffer[3]); //Print the loop Time\n        Oled.putString(\"  \"); //Blank space to erase previous characters\n        \n        Oled.setTextXY(5,9);          //Set the cursor to Xth Page, Yth Column  \n        Oled.putNumber(receiveBuffer[4]); //Print the ?\n        Oled.putString(\"    \"); //Blank space to erase previous characters\n        \n        Oled.setTextXY(6,9);          //Set the cursor to Xth Page, Yth Column  \n        Oled.putNumber(receiveBuffer[5]); //Print the ?\n        Oled.putString(\"    \"); //Blank space to erase previous characters\n        \n        Oled.setTextXY(7,9);          //Set the cursor to Xth Page, Yth Column\n        Oled.putNumber(receiveBuffer[6]); //Print the ?\n        Oled.putString(\"    \"); //Blank space to erase previous characters\n      } \n\n    } \n  //}\n // else{\n //   Serial.println(\"                         wait timeout\");\n // }\n \n// ================================================================\n// ===                   Write to OLED Display                  ===\n// ================================================================\n\n\n  //counter++;\n\n\n  \n  \n} // End main loop\n\n",
			"file": "/C/Users/hilo90mhz/Documents/GitHub/Cubic_Inch_Remote_2014/Cubic_Inch_Remote_2014.ino",
			"file_size": 11395,
			"file_write_time": 130592726552178283,
			"settings":
			{
				"buffer_size": 11126,
				"line_ending": "Windows"
			}
		}
	],
	"build_system": "",
	"command_palette":
	{
		"height": 311.0,
		"selected_items":
		[
			[
				"Package Control: ",
				"Package Control: Install Package"
			]
		],
		"width": 400.0
	},
	"console":
	{
		"height": 174.0,
		"history":
		[
			"import urllib.request,os,hashlib; h = '7183a2d3e96f11eeadd761d777e62404' + 'e330c659d4bb41d3bdf022e94cab3cd0'; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( 'http://packagecontrol.io/' + pf.replace(' ', '%20')).read(); dh = hashlib.sha256(by).hexdigest(); print('Error validating download (got %s instead of %s), please try manual install' % (dh, h)) if dh != h else open(os.path.join( ipp, pf), 'wb' ).write(by)"
		]
	},
	"distraction_free":
	{
		"menu_visible": true,
		"show_minimap": false,
		"show_open_files": false,
		"show_tabs": false,
		"side_bar_visible": false,
		"status_bar_visible": false
	},
	"expanded_folders":
	[
		"/C/Users/hilo90mhz/Documents/GitHub/Cubic_Inch_Robot_2014",
		"/C/Users/hilo90mhz/Documents/GitHub/Cubic_Inch_Remote_2014"
	],
	"file_history":
	[
		"/C/Users/hilo90mhz/Documents/GitHub/Cubic_Inch_Robot_2014/Cubic_Inch_Robot_2014.ino",
		"/C/Users/hilo90mhz/Documents/GitHub/Cubic_Inch_Robot_2014/PID_CL_2014.h",
		"/C/Users/hilo90mhz/Documents/GitHub/Cubic_Inch_Robot_2014/PID_CL_2014.cpp",
		"/C/Users/hilo90mhz/Documents/GitHub/Cubic_Inch_Robot_2014/Cubic_Inch_Robot_2014.sublime-project",
		"/C/Users/hilo90mhz/Documents/GitHub/Cubic_Inch_Robot_2014/stino.settings",
		"/C/Users/hilo90mhz/Google Drive/Arduino/Cubic_Inch_Robot_2014/PID_CL_2014.cpp",
		"/C/Users/hilo90mhz/Google Drive/Arduino/Cubic_Inch_Robot_2014/Cubic_Inch_Robot_2014.ino",
		"/C/Users/hilo90mhz/Google Drive/Arduino/Microbot_CI_2014_V1_0_0b/Microbot_CI_2014_V1_0_0b.ino"
	],
	"find":
	{
		"height": 39.0
	},
	"find_in_files":
	{
		"height": 0.0,
		"where_history":
		[
		]
	},
	"find_state":
	{
		"case_sensitive": false,
		"find_history":
		[
			"pid"
		],
		"highlight": true,
		"in_selection": false,
		"preserve_case": false,
		"regex": false,
		"replace_history":
		[
		],
		"reverse": false,
		"show_context": true,
		"use_buffer2": true,
		"whole_word": false,
		"wrap": true
	},
	"groups":
	[
		{
			"selected": 0,
			"sheets":
			[
				{
					"buffer": 0,
					"file": "Cubic_Inch_Robot_2014.ino",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 25589,
						"regions":
						{
						},
						"selection":
						[
							[
								2145,
								2145
							]
						],
						"settings":
						{
							"syntax": "Packages/Arduino-like IDE/Arduino.tmLanguage",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 10788.0,
						"zoom_level": 1.0
					},
					"stack_index": 0,
					"type": "text"
				},
				{
					"buffer": 1,
					"file": "/C/Users/hilo90mhz/Documents/GitHub/Cubic_Inch_Remote_2014/Cubic_Inch_Remote_2014.ino",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 11126,
						"regions":
						{
						},
						"selection":
						[
							[
								11106,
								11106
							]
						],
						"settings":
						{
							"syntax": "Packages/Arduino-like IDE/Arduino.tmLanguage",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 7118.0,
						"zoom_level": 1.0
					},
					"stack_index": 1,
					"type": "text"
				}
			]
		}
	],
	"incremental_find":
	{
		"height": 39.0
	},
	"input":
	{
		"height": 38.0
	},
	"layout":
	{
		"cells":
		[
			[
				0,
				0,
				1,
				1
			]
		],
		"cols":
		[
			0.0,
			1.0
		],
		"rows":
		[
			0.0,
			1.0
		]
	},
	"menu_visible": false,
	"output.Blink":
	{
		"height": 276.0
	},
	"output.Cubic_Inch_Remote_2014":
	{
		"height": 142.0
	},
	"output.Cubic_Inch_Robot_2014":
	{
		"height": 279.0
	},
	"output.MarlinChester":
	{
		"height": 268.0
	},
	"output.Microbot_CI_2014_V1_0_0b":
	{
		"height": 142.0
	},
	"output.find_results":
	{
		"height": 0.0
	},
	"output.stino_log":
	{
		"height": 142.0
	},
	"output.zumo2":
	{
		"height": 224.0
	},
	"project": "Cubic_Inch_Robot_2014.sublime-project",
	"replace":
	{
		"height": 74.0
	},
	"save_all_on_build": true,
	"select_file":
	{
		"height": 0.0,
		"selected_items":
		[
		],
		"width": 0.0
	},
	"select_project":
	{
		"height": 0.0,
		"selected_items":
		[
		],
		"width": 0.0
	},
	"select_symbol":
	{
		"height": 0.0,
		"selected_items":
		[
		],
		"width": 0.0
	},
	"selected_group": 0,
	"settings":
	{
	},
	"show_minimap": true,
	"show_open_files": false,
	"show_tabs": true,
	"side_bar_visible": true,
	"side_bar_width": 316.0,
	"status_bar_visible": true,
	"template_settings":
	{
	}
}
